{
  "NASM Boilerplate": {
    "prefix": "asmstart",
    "body": [
      "section .data",
      "\t; Defined constants and initialized data go here",
      "",
      "section .bss",
      "\t; Uninitialized variables (buffers, arrays) go here",
      "",
      "section .text",
      "\tglobal _start",
      "",
      "_start:",
      "\t; ------------------------------------------------------------------------------------",
      "\t; SYSCALL REFERENCE (x86-64 Linux):",
      "\t; ID (rax) | Name      | Arg1 (rdi) | Arg2 (rsi) | Arg3 (rdx)",
      "\t; 0        | sys_read  | fd         | buf        | count",
      "\t; 1        | sys_write | fd         | buf        | count",
      "\t; 60       | sys_exit  | error_code | -          | -",
      "\t; ------------------------------------------------------------------------------------",
      "",
      "",
      "exit:",
      "\tmov rax, 60       ; sys_exit syscall number",
      "\txor rdi, rdi      ; Exit code 0 (success)",
      "\tsyscall"
    ],
    "description": "NASM x64 boilerplate"
  },
  "syscall": {
    "prefix": "sscll",
    "body": [
      "\tmov rax, ${1:1}    ; Syscall ID",
      "\tmov rdi, ${2:1}    ; Arg 1",
      "\tmov rsi, ${3:1}    ; Arg 2",
      "\tmov rdx, ${4:1}    ; Arg 3",
      "\tsyscall"
    ],
    "description": "Boilerplate for syscalls"
  },
  "getInput": {
    "prefix": "getInput",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "\t; getInput: Reads from STDIN",
      "\t; Args: rdi = buffer address, rsi = max size to read",
      "getInput:",
      "\tmov rdx, rsi      ; Arg3: count (bytes to read)",
      "\tmov rsi, rdi      ; Arg2: buffer address",
      "\txor rax, rax      ; sys_read is syscall #0",
      "\txor rdi, rdi      ; Arg1: file descriptor 0 is STDIN",
      "\tsyscall",
      "\t; Replace the newline character with a null terminator",
      "\tmov byte [rsi + rax - 1], 0",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for getInput. Usage: lea rdi, [msg] | lea rsi, [buffer] | call getInput"
  },
  "printNewLine": {
    "prefix": "printNewLine",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "printNewLine:",
      "\tmov rax, 1        ; sys_write",
      "\tmov rdi, 1        ; STDOUT",
      "\tmov rsi, newLine  ; Address of newline char (Make sure 'newLine' is in .data)",
      "\tmov rdx, 1        ; Length is 1 byte",
      "\tsyscall",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for printNewLine"
  },
  "print": {
    "prefix": "print",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "\t; print: Prints a null-terminated string to STDOUT",
      "\t; Args: rdi = address of string",
      "print:",
      "\tmov rsi, rdi      ; Arg2: buffer (string pointer)",
      "\tcall getLen       ; Calculate length (returned in rax)",
      "\tmov rdx, rax      ; Arg3: count (length)",
      "\tmov rax, 1        ; sys_write",
      "\tmov rdi, 1        ; STDOUT",
      "\tsyscall",
      "\tmov rax, rdx      ; Return number of chars printed",
      "printDone:",
      "\tret",
      "",
      "getLen:",
      "\txor rcx, rcx      ; Reset counter",
      "getLenLoop:",
      "\tmovzx rax, byte [rdi] ; Load byte",
      "\ttest rax, rax     ; Check if 0 (null terminator)",
      "\tjz getLenDone",
      "\tinc rcx           ; Increment length",
      "\tinc rdi           ; Move to next char",
      "\tjmp getLenLoop",
      "getLenDone:",
      "\tmov rax, rcx      ; Return length in rax",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for print"
  },
  "getLen": {
    "prefix": "getLen",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "\t; getLen: Calculates length of null-terminated string",
      "\t; Args: rdi = string address. Returns: rax = length",
      "getLen:",
      "\txor rcx, rcx      ; Zero out counter",
      "getLenLoop:",
      "\tmovzx rax, byte [rdi] ; Read byte",
      "\ttest rax, rax     ; Check for null terminator",
      "\tjz getLenDone",
      "\tinc rcx           ; Increment count",
      "\tinc rdi           ; Next char",
      "\tjmp getLenLoop",
      "getLenDone:",
      "\tmov rax, rcx      ; Store result in rax",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for getLen"
  },
  "println": {
    "prefix": "println",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "println:",
      "\tcall print        ; Print the string",
      "\tpush rax          ; Save rax (return value of print) if needed",
      "\tcall printNewLine ; Print the \\n",
      "\tpop rax           ; Restore rax",
      "\tret",
      "printNewLine:",
      "\tmov rax, 1",
      "\tmov rdi, 1",
      "\tmov rsi, newLine  ; Ensure 'newLine db 10, 0' is in .data",
      "\tmov rdx, 1",
      "\tsyscall",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for println"
  },
  "strToNum": {
    "prefix": "strToNum",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "\t; strToNum (atoi): Converts string to integer",
      "\t; Args: rdi = string address. Returns: rax = integer",
      "strToNum:",
      "\txor rax, rax      ; Accumulator",
      "\tmov rbx, 10       ; Base 10",
      "\txor rcx, rcx      ; Digit holder",
      "strToNumLoop:",
      "\tmovzx rcx, byte [rdi]",
      "\ttest rcx, rcx     ; Check for null terminator",
      "\tjz strToNumDone",
      "\tsub rcx, '0'      ; Convert ASCII to Integer",
      "\tcmp rcx, 9        ; Check if valid digit (0-9)",
      "\tja strToNumDone   ; If > 9 (unsigned), it's not a digit",
      "\timul rax, rbx     ; rax = rax * 10",
      "\tadd rax, rcx      ; rax = rax + digit",
      "\tinc rdi           ; Next char",
      "\tjmp strToNumLoop",
      "strToNumDone:",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for strToNum"
  },
  "numToStr": {
    "prefix": "numToStr",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "\t; numToStr (itoa): Converts integer to string",
      "\t; Args: rdi = integer. Writes to 'numToStrBuff'",
      "\t; WARN: Requires 'numToStrBuff' in .bss",
      "numToStr:",
      "\tmov rbx, 10       ; Divisor",
      "\tmov rax, rdi      ; Number to convert",
      "\txor rcx, rcx      ; Digit counter",
      "numToStrLoop:",
      "\txor rdx, rdx      ; Clear remainder for div",
      "\tdiv rbx           ; rax / 10. Quotient in rax, Remainder in rdx",
      "\tadd rdx, '0'      ; Convert remainder to ASCII",
      "\tpush rdx          ; Push to stack (digits are calculated backwards)",
      "\tinc rcx           ; Count digits",
      "\ttest rax, rax     ; If quotient is 0, we are done",
      "\tjne numToStrLoop",
      "\txor r8, r8        ; Buffer index",
      "popIt:",
      "\tpop rax           ; Pop digit from stack",
      "\tmov [numToStrBuff + r8], al ; Store in buffer",
      "\tinc r8",
      "\tcmp r8, rcx       ; Check if we popped all digits",
      "\tjne popIt",
      "\tmov byte [numToStrBuff + rcx], 0 ; Null terminate",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for numToStr"
  },
  "getInputForArrayLoop": {
    "prefix": "getInputForArrayLoop",
    "body": [
      "getInputForArray:",
      "\tpush r12",
      "\tpush r13",
      "\tpush r14",
      "\tpush r15",
      "\tmov r12, rdi ; Where to write (buffer)",
      "\tmov r13, rsi ; Where to store pointers of array elements",
      "\tmov r14, rdx ; Max size to read from stdin",
      "\txor r15, r15",
      "getInputForArrayLoop:",
      "\tlea rdi, [msg]",
      "\tcall print",
      "\tmov rdi, r12",
      "\tmov rsi, r14",
      "\tmov [r13 + r15 * 8], rdi",
      "\tcall getInput",
      "\tadd r12, rax",
      "\tinc r15",
      "\tcmp r15, 4",
      "\tjne getInputForArrayLoop",
      "\tlea rax, [nullTerm]",
      "\tmov [r13 + r15 * 8], rax",
      "\tpop r15",
      "\tpop r14",
      "\tpop r13",
      "\tpop r12",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for getInputForArray"
  },
  "printArray": {
    "prefix": "printArray",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "\t; printArray: Iterates an array of string pointers",
      "\t; Args: rdi = pointer to the array (e.g., 'array' in .bss)",
      "printArray:",
      "\tpush rbx          ; Save callee-saved register",
      "\tmov rbx, rdi      ; Move array pointer to rbx",
      "printArrayLoop:",
      "\tmov rdi, [rbx]    ; Load string pointer from array",
      "\tcmp byte [rdi], 0 ; Check if pointer points to empty string/null",
      "\tje printArrayDone",
      "\tcall print        ; Print current string",
      "\tcall printSpace   ; Print separator",
      "\tadd rbx, 8        ; Move to next pointer (64-bit = 8 bytes)",
      "\tjmp printArrayLoop",
      "printArrayDone:",
      "\tpop rbx           ; Restore rbx",
      "\tret",
      "printSpace:",
      "\tmov rax, 1",
      "\tmov rdi, 1",
      "\tlea rsi, [space]  ; Ensure 'space db 32, 0' is in .data",
      "\tmov rdx, 1",
      "\tsyscall",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for printArray"
  },
  "printArrayLn": {
    "prefix": "printArrayLn",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "\t; printArrayLn: Same as printArray but with newlines",
      "printArrayLn:",
      "\tpush rbx",
      "\tmov rbx, rdi",
      "printArrayLnLoop:",
      "\tmov rdi, [rbx]",
      "\tcmp byte [rdi], 0",
      "\tje printArrayLnDone",
      "\tcall println      ; Uses println instead of print",
      "\tadd rbx, 8",
      "\tjmp printArrayLnLoop",
      "printArrayLnDone:",
      "\tpop rbx",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for printArrayLn"
  },
  "splitBySpace": {
    "prefix": "splitBySpace",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "\t; splitBySpace: Tokenizes a string by spaces",
      "\t; Args: rdi = source string, rsi = pointer array to store results",
      "splitBySpace:",
      "\txor rcx, rcx      ; Token counter",
      "splitBySpaceLoop:",
      "\tcmp byte [rdi], 0 ; End of string?",
      "\tje splitBySpaceDone",
      "\tcall skipSpaces   ; Move rdi past any leading spaces",
      "\tcmp byte [rdi], 0",
      "\tje splitBySpaceDone",
      "\tmov [rsi + rcx * 8], rdi ; Store start of this word in array",
      "\tinc rcx",
      "\tcall skipToEnd    ; Move rdi to the end of this word",
      "\tcmp byte [rdi], 0",
      "\tje splitBySpaceDone",
      "\tmov byte [rdi], 0 ; Null-terminate the word here",
      "\tinc rdi           ; Move to start of next potential word",
      "\tjmp splitBySpaceLoop",
      "splitBySpaceDone:",
      "\tlea rax, [nullTerm] ; Ensure nullTerm is defined or use 0",
      "\tmov qword [rsi + rcx * 8], rax ; Null terminate the array itself",
      "\tret",
      "",
      "skipSpaces:",
      "\tcmp byte [rdi], ' '",
      "\tjne skipSpacesDone",
      "\tinc rdi",
      "\tjmp skipSpaces",
      "skipSpacesDone:",
      "\tret",
      "",
      "skipToEnd:",
      "\tcmp byte [rdi], 0",
      "\tje skipToEndDone",
      "\tcmp byte [rdi], ' '",
      "\tje skipToEndDone",
      "\tinc rdi",
      "\tjmp skipToEnd",
      "skipToEndDone:",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for splitBySpace"
  },
  "strcmp": {
    "prefix": "strcmp",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "\t; strcmp: Compare two strings",
      "\t; Args: rdi = str1, rsi = str2. Returns: rax (0 if equal)",
      "strcmp:",
      "\tpush rbx",
      "strcmpLoop:",
      "\tmovzx rax, byte [rdi] ; Load char from str1",
      "\tmovzx rbx, byte [rsi] ; Load char from str2",
      "\tcmp rax, rbx",
      "\tjne strcmpDone        ; If not equal, we are done",
      "\ttest rax, rax",
      "\tje strcmpDone         ; If null terminator (and equal), done",
      "\ttest rbx, rbx",
      "\tje strcmpDone",
      "\tinc rdi",
      "\tinc rsi",
      "\tjmp strcmpLoop",
      "strcmpDone:",
      "\tsub rax, rbx          ; Calculate difference (0 = match)",
      "\tpop rbx",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for strcmp"
  },
  "echo": {
    "prefix": "echo",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "\t; echo: Simple REPL loop",
      "echo:",
      "\tlea rdi, [tokens + 8] ; Skip first token (usually command name)",
      "\tmov rax, [rdi]        ; Load pointer",
      "\ttest rax, rax",
      "\tje _start             ; If empty, restart",
      "\tcall printArray",
      "\tcall printNewLine",
      "\tjmp _start",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for echo"
  },
  "sectionDivider": {
    "prefix": "div",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "\t; $0",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Comment block divider"
  }
}
