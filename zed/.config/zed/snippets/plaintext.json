{
  "NASM Boilerplate": {
    "prefix": "asmstart",
    "body": [
      "section .data",
      "\t",
      "",
      "section .bss",
      "\t",
      "",
      "section .text",
      "\tglobal _start",
      "",
      "_start:",
      "\t; ------------------------------------------------------------------------------------",
      "\t; SYSCALL REFERENCE (x86-64 Linux):",
      "\t; 1) rax. 2) rdi. 3) rsi 4) rdx. 5) rcx. 6) r8.  rax == quotent rdx == remainder",
      "\t; ------------------------------------------------------------------------------------",
      "",
      "",
      "",
      "exit:",
      "\tmov rax, 60",
      "\txor rdi, rdi",
      "\tsyscall"
    ],
    "description": "NASM x64 boilerplate"
  },
  "syscall": {
    "prefix": "sscll",
    "body": [
      "\tmov rax,${1: 1}",
      "\tmov rdi,${2: 1}",
      "\tmov rsi,${3: 1}",
      "\tmov rdx,${4: 1}",
      "\tsyscall"
    ],
    "description": "Boilerplate for syscalls"
  },
  "getInput": {
    "prefix": "getInput",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "\t; getInput takes two args: rdi is the buffer the write to and rsi is the max size to read",
      "getInput:",
      "\tmov rdx, rsi",
      "\tmov rsi, rdi",
      "\txor rax, rax",
      "\txor rdi, rdi",
      "\tsyscall",
      "\tmov byte [rsi + rax - 1], 0",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for getInput. Usage: lea rdi, [msg] | lea rsi, [buffer] | call getInput | mov byte [buffer + rax], 0"
  },

  "printNewLine": {
    "prefix": "printNewLine",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "printNewLine:",
      "\tmov rax, 1",
      "\tmov rdi, 1",
      "\tmov rsi, newLine",
      "\tmov rdx, 1",
      "\tsyscall",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for printNewLine"
  },

  "print": {
    "prefix": "print",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "print:",
      "\tmov rsi, rdi",
      ";\tmovzx rax, byte [rdi]",
      ";\ttest rax, rax",
      ";\tje printDone",
      "\tcall getLen",
      "\tmov rdx, rax",
      "\tmov rax, 1",
      "\tmov rdi, 1",
      "\tsyscall",
      "\tmov rax, rdx ; print functions return the number of chars printed",
      "printDone:",
      "\tret",
      "getLen:",
      "\txor rcx, rcx",
      "getLenLoop:",
      "\tmovzx rax, byte [rdi]",
      "\ttest rax, rax",
      "\tjz getLenDone",
      "\tinc rcx",
      "\tinc rdi",
      "\tjmp getLenLoop",
      "getLenDone:",
      "\tmov rax, rcx",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for print"
  },

  "getLen": {
    "prefix": "getLen",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "getLen:",
      "\txor rcx, rcx",
      "getLenLoop:",
      "\tmovzx rax, byte [rdi]",
      "\ttest rax, rax",
      "\tjz getLenDone",
      "\tinc rcx",
      "\tinc rdi",
      "\tjmp getLenLoop",
      "getLenDone:",
      "\tmov rax, rcx",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for getLen"
  },

  "println": {
    "prefix": "println",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "println:",
      "\tcall print",
      "\tpush rax",
      "\tcall printNewLine",
      "\tpop rax",
      "\tret",
      "printNewLine:",
      "\tmov rax, 1",
      "\tmov rdi, 1",
      "\tmov rsi, newLine",
      "\tmov rdx, 1",
      "\tsyscall",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for println"
  },

  "strToNum": {
    "prefix": "strToNum",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "strToNum:",
      "\txor rax, rax",
      "\tmov rbx, 10",
      "\txor rcx, rcx",
      "strToNumLoop:",
      "\tmovzx rcx, byte [rdi]",
      "\ttest rcx, rcx",
      "\tjz strToNumDone",
      "\tsub rcx, '0'",
      "\tcmp rcx, 9",
      "\tja strToNumDone",
      "\timul rax, rbx",
      "\tadd rax, rcx",
      "\tinc rdi",
      "\tjmp strToNumLoop",
      "strToNumDone:",
      "ret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for strToNum"
  },

  "numToStr": {
    "prefix": "numToStr",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "numToStr:",
      "\tmov rbx, 10",
      "\tmov rax, rdi",
      "\txor rcx, rcx",
      "numToStrLoop:",
      "\txor rdx, rdx",
      "\tdiv rbx",
      "\tadd rdx, '0'",
      "\tpush rdx",
      "\tinc rcx",
      "\ttest rax, rax",
      "\tjne numToStrLoop",
      "\txor r8, r8",
      "popIt:",
      "\tpop rax",
      "\tmov [numToStrBuff + r8], al",
      "\tinc r8",
      "\tcmp r8, rcx",
      "\tjne popIt",
      "\tmov byte [numToStrBuff + rcx], 0",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for "
  },
  "getInputForArrayLoop": {
    "prefix": "getInputForArrayLoop",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "getInputForArray:",
      "\txor rax, rax",
      "\txor r12, r12",
      "\txor r13, r13",
      "getInputForArrayLoop:",
      "\tlea rdi, [msg]",
      "\tlea rsi, [buffer + r12]",
      "\tmov [array + r13 * 8], rsi",
      "\tinc r13",
      "\tcall getInput",
      "\tdec rax",
      "\tadd r12, rax",
      "\tmov byte [buffer + r12], 0",
      "\tinc r12",
      "\tcmp r13, 2",
      "\tjne getInputForArrayLoop",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for getInputForArray"
  },
  "printArray": {
    "prefix": "printArray",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "printArray:",
      "push rbx",
      "\tmov rbx, rdi",
      "printArrayLoop:",
      "\tmov rdi, [rbx]",
      "\tcmp byte [rdi], 0",
      "\tje printArrayDone",
      "\tcall print",
      "\tcall printSpace",
      "\tadd rbx, 8",
      "\tjmp printArrayLoop",
      "printArrayDone:",
      "\tpop rbx",
      "\tret",
      "printSpace:",
      "\tmov rax, 1",
      "\tmov rdi, 1",
      "\tlea rsi, [space]",
      "\tmov rdx, 1",
      "\tsyscall",
      "\tret",

      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for printArray"
  },
  "printArrayLn": {
    "prefix": "printArrayLn",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "printArrayLn:",
      "\tpush rbx",
      "\tmov rbx, rdi",
      "printArrayLnLoop:",
      "\tmov rdi, [rbx]",
      "\tcmp byte [rdi], 0",
      "\tje printArrayLnDone",
      "\tcall println",
      "\tadd rbx, 8",
      "\tjmp printArrayLnLoop",
      "printArrayLnDone:",
      "\tpop rbx",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for printArrayLn"
  },
  "splitBySpace": {
    "prefix": "splitBySpace",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "splitBySpace:",
      "\t; in rdi is the string to split",
      "\t; in rsi is the variable to store the result",
      "\txor rcx, rcx",
      "splitBySpaceLoop:",
      "\tcmp byte [rdi], 0",
      "\tje splitBySpaceDone",
      "\tcall skipSpaces",
      "\tcmp byte [rdi], 0",
      "\tje splitBySpaceDone",
      "\tmov [rsi + rcx * 8], rdi",
      "\tinc rcx",
      "\tcall skipToEnd",
      "\tcmp byte [rdi], 0",
      "\tje splitBySpaceDone",
      "\tmov byte [rdi], 0",
      "\tinc rdi",
      "\tjmp splitBySpaceLoop",
      "splitBySpaceDone:",
      "\tlea rax, [nullTerm]",
      "\tmov qword [rsi + rcx * 8], rax",
      "\tret",
      "skipSpaces:",
      "\tcmp byte [rdi], ' '",
      "\tjne skipSpacesDone",
      "\tinc rdi",
      "\tjmp skipSpaces",
      "skipSpacesDone:",
      "\tret",
      "skipToEnd:",
      "\tcmp byte [rdi], 0",
      "\tje skipToEndDone",
      "\tcmp byte [rdi], ' '",
      "\tje skipToEndDone",
      "\tinc rdi",
      "\tjmp skipToEnd",
      "skipToEndDone:",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for splitBySpace"
  },
  "strcmp": {
    "prefix": "strcmp",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "strcmp:",
      "\tpush rbx",
      "strcmpLoop:",
      "\tmovzx rax, byte [rdi]",
      "\tmovzx rbx, byte [rsi]",
      "\tcmp rax, rbx",
      "\tjne strcmpDone",
      "\ttest rax, rax",
      "\tje strcmpDone",
      "\ttest rbx, rbx",
      "\tje strcmpDone",
      "\tinc rdi",
      "\tinc rsi",
      "\tjmp strcmpLoop",
      "strcmpDone:",
      "\tsub rax, rbx",
      "\tpop rbx",
      "\tret",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for strcmp"
  },

  "echo": {
    "prefix": "echo",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "echo:",
      "\tlea rdi, [tokens + 8]",
      "\tmov rax, [rdi]",
      "\ttest rax, rax",
      "\tje _start",
      "\tcall printArray",
      "\tcall printNewLine",
      "\tjmp _start",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for echo"
  },
  "": {
    "prefix": "",
    "body": [
      "\t; -------------------------------------------------------------------------",
      "",
      "\t; -------------------------------------------------------------------------"
    ],
    "description": "Boilerplate for "
  }
}
